
macro logic m_rst := !c/rst_ni end macro;
macro logic m_clk := !c/clk_i end macro;

macro logic m_IF_rx := next(c/if_stage_i/instr_valid_id_o) end macro;// && (next(c/if_unit/id_stall) == 0)) end macro;
macro logic m_ID_rx := (true) end macro;
macro logic m_EX_rx := (true) end macro;
macro logic m_ME_rx := (true) end macro; // either no bubble or instruction finished in EX stage (if it stalls then it is still computing)
macro logic m_WB_rx := (true) end macro;

macro logic m_IF_tx := m_ID_rx end macro;
macro logic m_ID_tx := m_EX_rx end macro;
macro logic m_EX_tx := m_ME_rx end macro;
macro logic m_ME_tx := m_WB_rx end macro;
macro logic m_WB_tx := prev(true) end macro;

macro logic m_IF_flush := 0 end macro;
macro logic m_ID_flush := 0 end macro;
macro logic m_EX_flush := 0 end macro;
macro logic m_ME_flush := 0 end macro;
macro logic m_WB_flush := 0 end macro;
/*
macro unsigned m_IF_instr := c/if_unit/if_instr end macro;
macro unsigned m_ID_instr := c/id_unit/id_instr end macro;
macro unsigned m_EX_instr := c/ex_units/ex_instr end macro;
macro unsigned m_ME_instr := c/mem_unit/mem_instr end macro;
macro unsigned m_WB_instr := c/wb_unit/wb_instr_o end macro;

macro unsigned m_IF_pc := c/if_unit/if_pc end macro;
macro unsigned m_ID_pc := c/id_unit/id_pc end macro;
macro unsigned m_EX_pc := c/ex_units/ex_pc end macro;
macro unsigned m_ME_pc := c/mem_unit/mem_pc end macro;
macro unsigned m_WB_pc := c/wb_unit/wb_pc_o end macro;
*/

constraint c_no_reset :=
	!m_rst;
end constraint;

constraint c_no_debug :=
	if (!m_rst)
		debug_req_i == 0;
	endif;
end constraint;

constraint c_no_irq :=
	if (!m_rst)
		irq_i == 0;
	endif;
end constraint;

macro unsigned v_dmem_response_max_delay := 3 end macro;
constraint c_dmem_response_fairness :=
	if (!m_rst)
		if (data_req_o)
			exists i in 0..v_dmem_response_max_delay: next(data_rvalid_i,i) end exists
		endif
		&&
		if (data_rvalid_i)
			exists i in 0..v_dmem_response_max_delay: prev(data_req_o,i) end exists
			&&
			foreach i in 0..v_dmem_response_max_delay: prev(!m_rst,i) end foreach
		endif
	endif;
end constraint;

macro unsigned v_imem_response_max_delay := 3 end macro;
constraint c_imem_response_fairness :=
	if (!m_rst)
		if (instr_req_o)
			exists i in 0..v_imem_response_max_delay: next(instr_gnt_i,i) end exists
		endif
		&&
		if (instr_gnt_i)
			exists i in 0..v_imem_response_max_delay: prev(instr_req_o,i) end exists
			&&
			foreach i in 0..v_imem_response_max_delay: prev(!m_rst,i) end foreach
		endif
	endif;
end constraint;

constraint c_imem_response_valid :=
	if (!m_rst)
		instr_rvalid_i == prev(instr_gnt_i);
	endif;
end constraint;

constraint c_fetch_enable :=
	if (!m_rst)
		fetch_enable_i;
	endif;
end constraint;

/*
constraint c_no_st_flush :=
	if (!m_rst)
		((c/st_flush == 0) || prev(m_rst));
	endif;
end constraint;

constraint c_no_bu_flush :=
	if (!m_rst)
		((c/bu_flush == 0) || prev(m_rst));
	endif;
end constraint;

constraint c_no_if_stall_nxt_pc :=
	if (!m_rst)
		c/if_stall_nxt_pc == 0;
	endif;
end constraint;

constraint c_if_stall_nxt_pc_fairness :=
	if (!m_rst)
		exists i in 0..3:
			next(c/if_stall_nxt_pc,i) == 0;
		end exists;
	endif;
end constraint;

constraint c_if_nop :=
	if (!m_rst)
		c/if_instr == 32'h00000013;
	endif;
end constraint;

constraint c_id_nop :=
	if (!m_rst)
		c/id_instr == 32'h00000013;
	endif;
end constraint;

constraint c_ex_nop :=
	if (!m_rst)
		c/ex_instr == 32'h00000013;
	endif;
end constraint;

constraint c_no_ex_bubble :=
	if (!m_rst)
		c/ex_bubble == 0;
	endif;
end constraint;

constraint c_dmem_ready :=
	if (!m_rst)
		dmem_ack == 1;
	endif;
end constraint;

constraint c_dmem_fairness :=
	if (!m_rst)
		exists i in 0..3:
			next(dmem_ack,i) == 1;
		end exists;
	endif;
end constraint;

constraint c_if_parcel_valid :=
	if (!m_rst)
		((c/if_unit/pd_bubble == 0) || prev(m_rst) || prev(m_rst, 2));
	endif;
end constraint;

constraint c_if_parcel_valid2 :=
	if (!m_rst)
		(c/if_unit/if_parcel_misaligned == 0) &&
		(c/if_unit/if_parcel_page_fault == 0);
	endif;
end constraint;

constraint c_if_parcel_valid_fairness :=
	if (!m_rst)
		exists i in 0..4:
			next(c/if_unit/pd_bubble,i) == 0;
		end exists;
	endif;
end constraint;

constraint c_no_exception :=
	if (!m_rst)
		c/if_exception == 0 &&
		c/ex_exception == 0 &&
		c/mem_exception == 0 &&
		c/wb_exception == 0 &&
		c/id_exception == 0;
	endif;
end constraint;

constraint c_no_id_hazard :=
	if (!m_rst)
		(((c/id_unit/if_src1 != c/id_unit/id_dst) || prev(m_rst)) &&
		((c/id_unit/if_src2 != c/id_unit/id_dst) || prev(m_rst)) &&
		((c/id_unit/if_src1 != c/id_unit/ex_dst) || prev(m_rst, 2)) &&
		((c/id_unit/if_src2 != c/id_unit/ex_dst) || prev(m_rst, 2)));
	endif;
end constraint;
*/

// Macros that serve as helpers, eventually should be (g)enerated and not modified by the user

// tl stands for last token
macro logic mg_tl_IF_tx := (m_IF_tx && (IF_tcnt == 1)) end macro;
macro logic mg_tl_ID_rx := (m_ID_rx && next(ID_tcnt <= 1) && next(!tl_IF_tx_wait)) end macro;
macro logic mg_tl_ID_tx := (m_ID_tx && (ID_tcnt <= 1) && !tl_ID_rx_wait) end macro;
macro logic mg_tl_EX_rx := (m_EX_rx && next(EX_tcnt <= 1) && next(!tl_ID_tx_wait)) end macro;
macro logic mg_tl_EX_tx := (m_EX_tx && (EX_tcnt <= 1) && !tl_EX_rx_wait) end macro;
macro logic mg_tl_ME_rx := (m_ME_rx && next(ME_tcnt <= 1) && next(!tl_EX_tx_wait)) end macro;
macro logic mg_tl_ME_tx := (m_ME_tx && (ME_tcnt <= 1) && !tl_ME_rx_wait) end macro;
macro logic mg_tl_WB_rx := (m_WB_rx && next(WB_tcnt <= 1) && next(!tl_ME_tx_wait)) end macro;
macro logic mg_tl_WB_tx := (m_WB_tx && (WB_tcnt <= 1) && !tl_WB_rx_wait) end macro;


macro logic mg_t0_EX_rx := (m_EX_rx && next(EX_tcnt == 0) && next(!t0_ID_tx_wait)) end macro;
macro logic mg_t0_ME_rx := (m_ME_rx && next(ME_tcnt == 0) && next(!t0_EX_tx_wait)) end macro;
macro logic mg_t0_WB_rx := (m_WB_rx && next(WB_tcnt == 0) && next(!t0_ME_tx_wait)) end macro;

macro logic mg_t0_ID_tx := (m_ID_tx && (ID_tcnt == 0)) end macro;
macro logic mg_t0_EX_tx := (m_EX_tx && (EX_tcnt == 0) && !t0_EX_rx_wait) end macro;
macro logic mg_t0_ME_tx := (m_ME_tx && (ME_tcnt == 0) && !t0_ME_rx_wait) end macro;
macro logic mg_t0_WB_tx := (m_WB_tx && (WB_tcnt == 0) && !t0_WB_rx_wait) end macro;

macro logic mg_t1_IF_rx := ((IF_tcnt != 1) && next(IF_tcnt == 1)) end macro;
macro logic mg_t1_ID_rx := ((ID_tcnt != 1) && next(ID_tcnt == 1)) end macro;
macro logic mg_t1_EX_rx := ((EX_tcnt != 1) && next(EX_tcnt == 1)) end macro;
macro logic mg_t1_ME_rx := ((ME_tcnt != 1) && next(ME_tcnt == 1)) end macro;
macro logic mg_t1_WB_rx := ((WB_tcnt != 1) && next(WB_tcnt == 1)) end macro;

macro logic mg_t1_IF_tx := (m_IF_tx && (IF_tcnt == 1)) end macro;
macro logic mg_t1_ID_tx := (m_ID_tx && (ID_tcnt == 1)) end macro;
macro logic mg_t1_EX_tx := (m_EX_tx && (EX_tcnt == 1)) end macro;
macro logic mg_t1_ME_tx := (m_ME_tx && (ME_tcnt == 1)) end macro;
macro logic mg_t1_WB_tx := (m_WB_tx && (WB_tcnt == 1)) end macro;

macro logic mg_t2_IF_rx := ((IF_tcnt != 2) && next(IF_tcnt == 2)) end macro;
macro logic mg_t2_ID_rx := ((ID_tcnt != 2) && next(ID_tcnt == 2)) end macro;
macro logic mg_t2_EX_rx := ((EX_tcnt != 2) && next(EX_tcnt == 2)) end macro;
macro logic mg_t2_ME_rx := ((ME_tcnt != 2) && next(ME_tcnt == 2)) end macro;
macro logic mg_t2_WB_rx := ((WB_tcnt != 2) && next(WB_tcnt == 2)) end macro;

macro logic mg_t2_IF_tx := (m_IF_tx && (IF_tcnt == 2)) end macro;
macro logic mg_t2_ID_tx := (m_ID_tx && (ID_tcnt == 2)) end macro;
macro logic mg_t2_EX_tx := (m_EX_tx && (EX_tcnt == 2)) end macro;
macro logic mg_t2_ME_tx := (m_ME_tx && (ME_tcnt == 2)) end macro;
macro logic mg_t2_WB_tx := (m_WB_tx && (WB_tcnt == 2)) end macro;

macro logic mg_t3_IF_rx := ((IF_tcnt != 3) && next(IF_tcnt == 3)) end macro;
macro logic mg_t4_IF_rx := ((IF_tcnt != 4) && next(IF_tcnt == 4)) end macro;
macro logic mg_t5_IF_rx := ((IF_tcnt != 5) && next(IF_tcnt == 5)) end macro;

// TODO if there is skipped stage flush can be still triggered
macro logic mg_t0_ID_flush := (m_ID_flush && (ID_tcnt == 0)) end macro;
macro logic mg_t0_EX_flush := (m_EX_flush && (EX_tcnt == 0)) end macro;
macro logic mg_t0_ME_flush := (m_ME_flush && (ME_tcnt == 0)) end macro;
macro logic mg_t0_WB_flush := (m_WB_flush && (WB_tcnt == 0)) end macro;

macro logic mg_t1_ID_flush := (m_ID_flush && (ID_tcnt == 1)) end macro;
macro logic mg_t1_EX_flush := (m_EX_flush && (EX_tcnt == 1)) end macro;
macro logic mg_t1_ME_flush := (m_ME_flush && (ME_tcnt == 1)) end macro;
macro logic mg_t1_WB_flush := (m_WB_flush && (WB_tcnt == 1)) end macro;

macro logic mg_t1_flush := ((mg_t0_ID_flush || mg_t0_EX_flush || mg_t0_ME_flush || mg_t0_WB_flush) && (IF_tcnt > 0)) end macro;
macro logic mg_t2_flush := ((mg_t1_ID_flush || mg_t1_EX_flush || mg_t1_ME_flush || mg_t1_WB_flush) && (IF_tcnt > 1)) end macro;
macro logic mg_t3_flush := ((mg_t1_ID_flush || mg_t1_EX_flush || mg_t1_ME_flush || mg_t1_WB_flush) && (IF_tcnt > 2)) end macro;
macro logic mg_t4_flush := ((mg_t1_ID_flush || mg_t1_EX_flush || mg_t1_ME_flush || mg_t1_WB_flush) && (IF_tcnt > 3)) end macro;
macro logic mg_t5_flush := ((mg_t1_ID_flush || mg_t1_EX_flush || mg_t1_ME_flush || mg_t1_WB_flush) && (IF_tcnt > 4)) end macro;

/*
TODO:
	-try to match windows exactly (remove overlap)
*/

macro unsigned examination_window := 25 end macro;

property window_check;
//dependencies: c_no_debug, c_no_exception, c_no_st_flush, c_if_stall_nxt_pc_fairness, c_if_parcel_valid_fairness, c_dmem_fairness;

for timepoints:
	t2_IF_tx_f = t + 0..examination_window waits_for complete mg_t2_IF_tx,
	t2_ID_tx_f = t + 0..examination_window waits_for complete mg_t2_ID_tx,
	t2_EX_tx_f = t + 0..examination_window waits_for complete mg_t2_EX_tx,
	t2_ME_tx_f = t + 0..examination_window waits_for complete mg_t2_ME_tx,
	t2_WB_tx_f = t + 0..examination_window waits_for complete mg_t2_WB_tx,

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t2_IF_tx_exist = mg_t2_IF_tx@t2_IF_tx_f,
	at_t2_ID_tx_exist = mg_t2_ID_tx@t2_ID_tx_f,
	at_t2_EX_tx_exist = mg_t2_EX_tx@t2_EX_tx_f,
	at_t2_ME_tx_exist = mg_t2_ME_tx@t2_ME_tx_f,
	at_t2_WB_tx_exist = mg_t2_WB_tx@t2_WB_tx_f,

	at_t_dummy = m_clk@t_dummy; // last dummy line (for the semicolon)

assume:
/*
	// Need separate property to check each stage tx case
	// TODO: Find a simple way to combine these assumptions?
	// Note that each tx has to be the first occurance otherwise the property is not correct
	// Use floating inputs?


	at t+examination_window: mg_t2_IF_tx;
	during[t,t+examination_window-1]: !mg_t2_IF_tx;

	at t+examination_window: mg_t2_ID_tx;
	during[t,t+examination_window-1]: !mg_t2_ID_tx;

	at t+examination_window: mg_t2_EX_tx;
	during[t,t+examination_window-1]: !mg_t2_EX_tx;

	at t+examination_window: mg_t2_ME_tx;
	during[t,t+examination_window-1]: !mg_t2_ME_tx;

	at t+examination_window: mg_t2_WB_tx;
	during[t,t+examination_window-1]: !mg_t2_WB_tx;

*/

	at t+examination_window: (
			fell(next(t2_IF_tx_wait)) || 
			fell(next(t2_ID_tx_wait)) || 
			fell(next(t2_EX_tx_wait)) || 
			fell(next(t2_ME_tx_wait)) || 
			fell(next(t2_WB_tx_wait))
		);

	during[t,t2_IF_tx_f]: t2_IF_tx_wait == at_t2_IF_tx_exist;
	during[t2_IF_tx_f+1,t+examination_window]: !t2_IF_tx_wait;

	during[t,t2_ID_tx_f]: t2_ID_tx_wait == at_t2_ID_tx_exist;
	during[t2_ID_tx_f+1,t+examination_window]: !t2_ID_tx_wait;

	during[t,t2_EX_tx_f]: t2_EX_tx_wait == at_t2_EX_tx_exist;
	during[t2_EX_tx_f+1,t+examination_window]: !t2_EX_tx_wait;

	during[t,t2_ME_tx_f]: t2_ME_tx_wait == at_t2_ME_tx_exist;
	during[t2_ME_tx_f+1,t+examination_window]: !t2_ME_tx_wait;

	during[t,t2_WB_tx_f]: t2_WB_tx_wait == at_t2_WB_tx_exist;
	during[t2_WB_tx_f+1,t+examination_window]: !t2_WB_tx_wait;


    // Connect token counters
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;

	// Configure reset overlap
	during[t,t+examination_window]: !rose(m_rst);
	during[t,t+examination_window]: if (m_rst) IF_tcnt == 0 endif;
	during[t,t+examination_window]: if (m_rst) ID_tcnt == 0 endif;
	during[t,t+examination_window]: if (m_rst) EX_tcnt == 0 endif;
	during[t,t+examination_window]: if (m_rst) ME_tcnt == 0 endif;
	during[t,t+examination_window]: if (m_rst) WB_tcnt == 0 endif;

	// Prevent counter overflowing
	during[t,t+examination_window]: next(IF_tcnt) >= IF_tcnt;
	during[t,t+examination_window]: next(ID_tcnt) >= ID_tcnt;
	during[t,t+examination_window]: next(EX_tcnt) >= EX_tcnt;
	during[t,t+examination_window]: next(ME_tcnt) >= ME_tcnt;
	during[t,t+examination_window]: next(WB_tcnt) >= WB_tcnt;

prove:
	within[t,t+examination_window]: mg_t1_IF_rx;

end property;


property base;
dependencies: c_no_reset, c_no_debug, c_no_irq, c_imem_response_fairness, c_imem_response_valid, c_dmem_response_fairness, c_fetch_enable;
for timepoints:
	t1_IF_rx_n = t + 0..examination_window waits_for complete mg_t1_IF_rx,
	t2_IF_rx_n = t + 0..examination_window waits_for complete mg_t2_IF_rx,
	t3_IF_rx_n = t + 0..examination_window waits_for complete mg_t3_IF_rx,
	t4_IF_rx_n = t + 0..examination_window waits_for complete mg_t4_IF_rx,
	t5_IF_rx_n = t + 0..examination_window waits_for complete mg_t5_IF_rx,

	t1_flush_f = t + 0..examination_window waits_for complete mg_t1_flush,
	t2_flush_f = t + 0..examination_window waits_for complete mg_t2_flush,
	t3_flush_f = t + 0..examination_window waits_for complete mg_t3_flush,
	t4_flush_f = t + 0..examination_window waits_for complete mg_t4_flush,
	t5_flush_f = t + 0..examination_window waits_for complete mg_t5_flush,

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	// Freeze signals indicating flushing cases
	at_t1_flush = mg_t1_flush@t1_flush_f,
	at_t2_flush = mg_t2_flush@t2_flush_f,
	at_t3_flush = mg_t3_flush@t3_flush_f,
	at_t4_flush = mg_t4_flush@t4_flush_f,
	at_t5_flush = mg_t5_flush@t5_flush_f,

	at_t_dummy = m_clk@t_dummy; // last dummy line (for the semicolon)

assume:
    reset_sequence;

    // Connect token counters
	at t: IF_tcnt == 0;
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	at t: ID_tcnt == 0;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	at t: EX_tcnt == 0;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	at t: ME_tcnt == 0;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	at t: WB_tcnt == 0;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;
/*
	// For debugging
	during[t,t+examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+examination_window]: WB_instr_enum == getInstr(m_WB_instr);
*/
prove:
	at t: !at_t1_flush || !at_t2_flush || !at_t3_flush || !at_t4_flush || !at_t5_flush;

	at t1_IF_rx_n: mg_t1_IF_rx;
	at t2_IF_rx_n: if (at_t1_flush) mg_t2_IF_rx endif;
	at t3_IF_rx_n: if (at_t1_flush && at_t2_flush) mg_t3_IF_rx endif;
	at t4_IF_rx_n: if (at_t1_flush && at_t2_flush && at_t3_flush) mg_t4_IF_rx endif;
	at t5_IF_rx_n: if (at_t1_flush && at_t2_flush && at_t3_flush && at_t4_flush) mg_t5_IF_rx endif;

end property;

property flush_check;
dependencies: c_no_reset;//, c_no_debug, c_no_exception, c_no_st_flush, c_if_stall_nxt_pc_fairness, c_if_parcel_valid_fairness, c_dmem_fairness;
for timepoints:
	t1_IF_rx_n = t + 0..examination_window waits_for complete mg_t1_IF_rx,
	t2_IF_rx_n = t + 0..examination_window waits_for complete mg_t2_IF_rx,
	t3_IF_rx_n = t + 0..examination_window waits_for complete mg_t3_IF_rx,
	t4_IF_rx_n = t + 0..examination_window waits_for complete mg_t4_IF_rx,
	t5_IF_rx_n = t + 0..examination_window waits_for complete mg_t5_IF_rx,

	t1_flush_f = t + 0..examination_window waits_for complete mg_t1_flush,
	t2_flush_f = t + 0..examination_window waits_for complete mg_t2_flush,
	t3_flush_f = t + 0..examination_window waits_for complete mg_t3_flush,
	t4_flush_f = t + 0..examination_window waits_for complete mg_t4_flush,
	t5_flush_f = t + 0..examination_window waits_for complete mg_t5_flush,

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	// Freeze signals indicating flushing cases
	at_t1_flush = mg_t1_flush@t1_flush_f,
	at_t2_flush = mg_t2_flush@t2_flush_f,
	at_t3_flush = mg_t3_flush@t3_flush_f,
	at_t4_flush = mg_t4_flush@t4_flush_f,
	at_t5_flush = mg_t5_flush@t5_flush_f,

	at_t_dummy = m_clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_t1_IF_rx;

	// Make sure that property does not start at flushing
	at t: !at_t1_flush;

    // Connect token counters
	at t: IF_tcnt == 0;
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	at t: ID_tcnt == 0;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	at t: EX_tcnt == 0;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	at t: ME_tcnt == 0;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	at t: WB_tcnt == 0;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;
/*
	// For debugging
	during[t,t+examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+examination_window]: WB_instr_enum == getInstr(m_WB_instr);
*/
prove:
	at t: !at_t2_flush || !at_t3_flush || !at_t4_flush || !at_t5_flush;

	at t1_IF_rx_n: mg_t1_IF_rx;
	at t2_IF_rx_n: if (at_t1_flush) mg_t2_IF_rx endif;
	at t3_IF_rx_n: if (at_t1_flush && at_t2_flush) mg_t3_IF_rx endif;
	at t4_IF_rx_n: if (at_t1_flush && at_t2_flush && at_t3_flush) mg_t4_IF_rx endif;
	at t5_IF_rx_n: if (at_t1_flush && at_t2_flush && at_t3_flush && at_t4_flush) mg_t5_IF_rx endif;

end property;



property step;
dependencies: c_no_reset;//, c_no_debug, c_no_exception, c_no_st_flush, c_if_stall_nxt_pc_fairness, c_if_parcel_valid_fairness, c_dmem_fairness;
for timepoints:

	// This code detects last use of the stage that can come from either t1 or some older token if t1 contains skipped stages
	// tl detection
	tl_IF_tx_f = t + 0..examination_window waits_for complete mg_tl_IF_tx,
	tl_IF_tx_l = t + 0..examination_window waits_for complete next(!tl_IF_tx_wait), // Occurance after t

	tl_ID_rx_f = t + 0..examination_window waits_for complete mg_tl_ID_rx,
	tl_ID_rx_l1 = t + 0..examination_window waits_for complete next(!tl_ID_rx_wait), // Occurance after tl_IF_tx_l
	tl_ID_rx_l = max_timepoint(tl_ID_rx_l1, tl_IF_tx_l), 

	tl_ID_tx_f = t + 0..examination_window waits_for complete mg_tl_ID_tx,
	tl_ID_tx_l1 = t + 0..examination_window waits_for complete next(!tl_ID_tx_wait), // Occurance after tl_ID_rx_l1+1
	tl_ID_tx_l = max_timepoint(tl_ID_tx_l1, tl_ID_rx_l),

	tl_EX_rx_f = t + 0..examination_window waits_for complete mg_tl_EX_rx,
	tl_EX_rx_l1 = t + 0..examination_window waits_for complete next(!tl_EX_rx_wait), // Occurance after tl_ID_tx_l
	tl_EX_rx_l = max_timepoint(tl_EX_rx_l1, tl_ID_tx_l),

	tl_EX_tx_f = t + 0..examination_window waits_for complete mg_tl_EX_tx,
	tl_EX_tx_l1 = t + 0..examination_window waits_for complete next(!tl_EX_tx_wait), // Occurance after tl_EX_rx_l1+1
	tl_EX_tx_l = max_timepoint(tl_EX_tx_l1, tl_EX_rx_l),

	tl_ME_rx_f = t + 0..examination_window waits_for complete mg_tl_ME_rx,
	tl_ME_rx_l1 = t + 0..examination_window waits_for complete next(!tl_ME_rx_wait), // Occurance after tl_EX_tx_l1
	tl_ME_rx_l = max_timepoint(tl_ME_rx_l1, tl_EX_tx_l),

	tl_ME_tx_f = t + 0..examination_window waits_for complete mg_tl_ME_tx,
	tl_ME_tx_l1 = t + 0..examination_window waits_for complete next(!tl_ME_tx_wait), // Occurance after tl_ME_rx_l1+1
	tl_ME_tx_l = max_timepoint(tl_ME_tx_l1, tl_ME_rx_l),

	tl_WB_rx_f = t + 0..examination_window waits_for complete mg_tl_WB_rx,
	tl_WB_rx_l1 = t + 0..examination_window waits_for complete next(!tl_WB_rx_wait), // Occurance after tl_ME_tx_l1
	tl_WB_rx_l = max_timepoint(tl_WB_rx_l1, tl_ME_tx_l),

	tl_WB_tx_f = t + 0..examination_window waits_for complete mg_tl_WB_tx,
	tl_WB_tx_l1 = t + 0..examination_window waits_for complete next(!tl_WB_tx_wait), // Occurance after tl_WB_rx_l1+1
	tl_WB_tx_l = max_timepoint(tl_WB_tx_l1, tl_WB_rx_l),


	// t1 detection
	t1_IF_rx_n = t,

	// t2 detection
	t2_IF_rx_n = t + 0..examination_window waits_for complete mg_t2_IF_rx,

	t2_IF_tx_f = t + 0..examination_window waits_for complete mg_t2_IF_tx,
	t2_IF_tx_l1 = t + 0..examination_window waits_for complete next(!t2_IF_tx_wait),
	t2_IF_tx_l = max_timepoint(t2_IF_tx_l1, t2_IF_rx_n),

	t2_IF_wn_l = t2_IF_rx_n,
	t2_IF_wn_r = t + 0..examination_window waits_for complete (next(IF_tcnt) > 2),

	t2_ID_rx_f = t + 0..examination_window waits_for complete mg_t2_ID_rx,
	t2_ID_rx_l1 = t + 0..examination_window waits_for complete next(!t2_ID_rx_wait),
	t2_ID_rx_l2 = max_timepoint(t2_ID_rx_l1, t2_IF_tx_l),
	t2_ID_rx_l = max_timepoint(t2_ID_rx_l2, tl_EX_rx_l),

	t2_ID_tx_f = t + 0..examination_window waits_for complete mg_t2_ID_tx,
	t2_ID_tx_l1 = t + 0..examination_window waits_for complete next(!t2_ID_tx_wait),
	t2_ID_tx_l = max_timepoint(t2_ID_tx_l1, t2_ID_rx_l),

	t2_ID_wn_l = t2_ID_rx_l,
	t2_ID_wn_r = t + 0..examination_window waits_for complete (next(ID_tcnt) > 2),

	t2_EX_rx_f = t + 0..examination_window waits_for complete mg_t2_EX_rx,
	t2_EX_rx_l1 = t + 0..examination_window waits_for complete next(!t2_EX_rx_wait),
	t2_EX_rx_l2 = max_timepoint(t2_EX_rx_l1, t2_ID_tx_l),
	t2_EX_rx_l = max_timepoint(t2_EX_rx_l2, tl_ME_rx_l),

	t2_EX_tx_f = t + 0..examination_window waits_for complete mg_t2_EX_tx,
	t2_EX_tx_l1 = t + 0..examination_window waits_for complete next(!t2_EX_tx_wait),
	t2_EX_tx_l = max_timepoint(t2_EX_tx_l1, t2_EX_rx_l),

	t2_EX_wn_l = t2_EX_rx_l,
	t2_EX_wn_r = t + 0..examination_window waits_for complete (next(EX_tcnt) > 2),

	t2_ME_rx_f = t + 0..examination_window waits_for complete mg_t2_ME_rx,
	t2_ME_rx_l1 = t + 0..examination_window waits_for complete next(!t2_ME_rx_wait),
	t2_ME_rx_l2 = max_timepoint(t2_ME_rx_l1, t2_EX_tx_l),
	t2_ME_rx_l = max_timepoint(t2_ME_rx_l2, tl_WB_rx_l),

	t2_ME_tx_f = t + 0..examination_window waits_for complete mg_t2_ME_tx,
	t2_ME_tx_l1 = t + 0..examination_window waits_for complete next(!t2_ME_tx_wait),
	t2_ME_tx_l = max_timepoint(t2_ME_tx_l1, t2_ME_rx_l),

	t2_ME_wn_l = t2_ME_rx_l,
	t2_ME_wn_r = t + 0..examination_window waits_for complete (next(ME_tcnt) > 2),

	t2_WB_rx_f = t + 0..examination_window waits_for complete mg_t2_WB_rx,
	t2_WB_rx_l1 = t + 0..examination_window waits_for complete next(!t2_WB_rx_wait),
	t2_WB_rx_l2 = max_timepoint(t2_WB_rx_l1, t2_ME_tx_l),
	t2_WB_rx_l = max_timepoint(t2_WB_rx_l2, tl_WB_tx_l), // special case since it is the last pipeline stage

	t2_WB_tx_f = t + 0..examination_window waits_for complete mg_t2_WB_tx,

	t2_WB_wn_l = t2_WB_rx_l,
	t2_WB_wn_r = t + 0..examination_window waits_for complete (next(WB_tcnt) > 2),


	// Detect flushing cases
	t1_flush_f = t + 0..examination_window waits_for complete mg_t1_flush,
	t2_flush_f = t + 0..examination_window waits_for complete mg_t2_flush,
	t3_flush_f = t + 0..examination_window waits_for complete mg_t3_flush,
	t4_flush_f = t + 0..examination_window waits_for complete mg_t4_flush,
	t5_flush_f = t + 0..examination_window waits_for complete mg_t5_flush,

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_tl_IF_tx_exist = mg_tl_IF_tx@tl_IF_tx_f,
	at_tl_ID_rx_exist = mg_tl_ID_rx@tl_ID_rx_f,
	at_tl_ID_tx_exist = mg_tl_ID_tx@tl_ID_tx_f,
	at_tl_EX_rx_exist = mg_tl_EX_rx@tl_EX_rx_f,
	at_tl_EX_tx_exist = mg_tl_EX_tx@tl_EX_tx_f,
	at_tl_ME_rx_exist = mg_tl_ME_rx@tl_ME_rx_f,
	at_tl_ME_tx_exist = mg_tl_ME_tx@tl_ME_tx_f,
	at_tl_WB_rx_exist = mg_tl_WB_rx@tl_WB_rx_f,
	at_tl_WB_tx_exist = mg_tl_WB_tx@tl_WB_tx_f,

	at_t2_IF_tx_exist = mg_t2_IF_tx@t2_IF_tx_f,
	at_t2_ID_rx_exist = mg_t2_ID_rx@t2_ID_rx_f,
	at_t2_ID_tx_exist = mg_t2_ID_tx@t2_ID_tx_f,
	at_t2_EX_rx_exist = mg_t2_EX_rx@t2_EX_rx_f,
	at_t2_EX_tx_exist = mg_t2_EX_tx@t2_EX_tx_f,
	at_t2_ME_rx_exist = mg_t2_ME_rx@t2_ME_rx_f,
	at_t2_ME_tx_exist = mg_t2_ME_tx@t2_ME_tx_f,
	at_t2_WB_rx_exist = mg_t2_WB_rx@t2_WB_rx_f,

	// Freeze signals indicating flushing cases
	at_t1_flush = mg_t1_flush@t1_flush_f,
	at_t2_flush = mg_t2_flush@t2_flush_f,
	at_t3_flush = mg_t3_flush@t3_flush_f,
	at_t4_flush = mg_t4_flush@t4_flush_f,
	at_t5_flush = mg_t5_flush@t5_flush_f,
/*
	at_t2_IF_tx_instr = m_IF_instr@t2_IF_tx_f,
	at_t2_ID_tx_instr = m_ID_instr@t2_ID_tx_f,
	at_t2_EX_tx_instr = m_EX_instr@t2_EX_tx_f,
	at_t2_ME_tx_instr = m_ME_instr@t2_ME_tx_f,
	at_t2_WB_tx_instr = m_WB_instr@t2_WB_tx_f,

	at_t2_IF_tx_pc = m_IF_pc@t2_IF_tx_f,
	at_t2_ID_tx_pc = m_ID_pc@t2_ID_tx_f,
	at_t2_EX_tx_pc = m_EX_pc@t2_EX_tx_f,
	at_t2_ME_tx_pc = m_ME_pc@t2_ME_tx_f,
	at_t2_WB_tx_pc = m_WB_pc@t2_WB_tx_f,
*/
	at_t_dummy = m_clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_t1_IF_rx;

	// Make sure that property does not start at flushing and no flushing occur withing the window
	at t: !at_t1_flush;
	at t: !at_t2_flush;

	//within[t,t+examination_window]: t0_WB_tx_wait == true;

	// Connect token counters
	at t: IF_tcnt == 0;
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	at t: ID_tcnt == 0;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	at t: EX_tcnt == 0;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	at t: ME_tcnt == 0;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	at t: WB_tcnt == 0;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;

	// Connect transaction flag variables
	during[t,tl_IF_tx_f]: tl_IF_tx_wait == at_tl_IF_tx_exist;
	during[tl_IF_tx_f+1,t+examination_window]: !tl_IF_tx_wait;

	during[t,tl_ID_rx_f]: tl_ID_rx_wait == at_tl_ID_rx_exist;
	during[tl_ID_rx_f+1,t+examination_window]: !tl_ID_rx_wait;

	during[t,tl_ID_tx_f]: tl_ID_tx_wait == at_tl_ID_tx_exist;
	during[tl_ID_tx_f+1,t+examination_window]: !tl_ID_tx_wait;

	during[t,tl_EX_rx_f]: tl_EX_rx_wait == at_tl_EX_rx_exist;
	during[tl_EX_rx_f+1,t+examination_window]: !tl_EX_rx_wait;

	during[t,tl_EX_tx_f]: tl_EX_tx_wait == at_tl_EX_tx_exist;
	during[tl_EX_tx_f+1,t+examination_window]: !tl_EX_tx_wait;

	during[t,tl_ME_rx_f]: tl_ME_rx_wait == at_tl_ME_rx_exist;
	during[tl_ME_rx_f+1,t+examination_window]: !tl_ME_rx_wait;	

	during[t,tl_ME_tx_f]: tl_ME_tx_wait == at_tl_ME_tx_exist;
	during[tl_ME_tx_f+1,t+examination_window]: !tl_ME_tx_wait;

	during[t,tl_WB_rx_f]: tl_WB_rx_wait == at_tl_WB_rx_exist;
	during[tl_WB_rx_f+1,t+examination_window]: !tl_WB_rx_wait;	

	during[t,tl_WB_tx_f]: tl_WB_tx_wait == at_tl_WB_tx_exist;
	during[tl_WB_tx_f+1,t+examination_window]: !tl_WB_tx_wait;


	during[t,t2_IF_tx_f]: t2_IF_tx_wait == at_t2_IF_tx_exist;
	during[t2_IF_tx_f+1,t+examination_window]: !t2_IF_tx_wait;

	during[t,t2_ID_rx_f]: t2_ID_rx_wait == at_t2_ID_rx_exist;
	during[t2_ID_rx_f+1,t+examination_window]: !t2_ID_rx_wait;

	during[t,t2_ID_tx_f]: t2_ID_tx_wait == at_t2_ID_tx_exist;
	during[t2_ID_tx_f+1,t+examination_window]: !t2_ID_tx_wait;

	during[t,t2_EX_rx_f]: t2_EX_rx_wait == at_t2_EX_rx_exist;
	during[t2_EX_rx_f+1,t+examination_window]: !t2_EX_rx_wait;

	during[t,t2_EX_tx_f]: t2_EX_tx_wait == at_t2_EX_tx_exist;
	during[t2_EX_tx_f+1,t+examination_window]: !t2_EX_tx_wait;

	during[t,t2_ME_rx_f]: t2_ME_rx_wait == at_t2_ME_rx_exist;
	during[t2_ME_rx_f+1,t+examination_window]: !t2_ME_rx_wait;

	during[t,t2_ME_tx_f]: t2_ME_tx_wait == at_t2_ME_tx_exist;
	during[t2_ME_tx_f+1,t+examination_window]: !t2_ME_tx_wait;	

	during[t,t2_WB_rx_f]: t2_WB_rx_wait == at_t2_WB_rx_exist;
	during[t2_WB_rx_f+1,t+examination_window]: !t2_WB_rx_wait;
/*
	// For debugging
	during[t,t+examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+examination_window]: WB_instr_enum == getInstr(m_WB_instr);
*/
prove:
	at t2_IF_rx_n: mg_t2_IF_rx;

/*
	at t: !at_t2_flush || !at_t3_flush || !at_t4_flush || !at_t5_flush;
	at t2_IF_rx_n: mg_t2_IF_rx;
	at t3_IF_rx_n: if (at_t2_flush) mg_t3_IF_rx endif;
	at t4_IF_rx_n: if (at_t2_flush && at_t3_flush) mg_t4_IF_rx endif;
	at t5_IF_rx_n: if (at_t2_flush && at_t3_flush && at_t4_flush) mg_t5_IF_rx endif;
*/
/*
	at t2_ID_tx_f: m_ID_instr == at_t2_IF_tx_instr;
	at t2_EX_tx_f: m_EX_instr == at_t2_ID_tx_instr;
	at t2_ME_tx_f: m_ME_instr == at_t2_EX_tx_instr;
	at t2_WB_tx_f: m_WB_instr == at_t2_ME_tx_instr;

	at t2_ID_tx_f: m_ID_pc == at_t2_IF_tx_pc;
	at t2_EX_tx_f: m_EX_pc == at_t2_ID_tx_pc;
	at t2_ME_tx_f: m_ME_pc == at_t2_EX_tx_pc;
	at t2_WB_tx_f: m_WB_pc == at_t2_ME_tx_pc;
*/
	// Prove right hook
	at t2_IF_tx_f: mg_t2_IF_tx;
	at t2_ID_rx_f: mg_t2_ID_rx;
	at t2_ID_tx_f: mg_t2_ID_tx;
	at t2_EX_rx_f: mg_t2_EX_rx;
	at t2_EX_tx_f: mg_t2_EX_tx;
	at t2_ME_rx_f: mg_t2_ME_rx;
	at t2_ME_tx_f: mg_t2_ME_tx;
	at t2_WB_rx_f: mg_t2_WB_rx;
	at t2_WB_tx_f: mg_t2_WB_tx;

end property;
